#include<iostream>
using namespace std;
int f[1005];

int find(int x){
    if(f[x]==x){return x;}
    return f[x]=find(f[x]);
}

int main(){
    int n,m;
    while(cin>>n&&n!=0){
        cin>>m;
        for(int i=1;i<=n;++i){
            f[i]=i;
        }

        for(int j=0;j<m;++j){
            int a,b;
            cin>>a;
            cin>>b;
            int x1 = find(a);
            int x2 = find(b);
            if(x1!=x2){
                f[x1]=x2;
            }
        }

        int count = 0;
        for(int i=1;i<=n;++i){
            if(f[i]==i){
                count++;
            }
        }
        cout<<count - 1<<endl;
    }
    return 0;
}
//在这段代码中，`count` 表示的是连通分量的个数。题目中的 `n` 代表城市的数量，`m` 代表道路的数量。代码的目标是计算需要修建多少条新的道路，才能将所有城市连通起来。
### 为什么 `count - 1`？
- **连通分量的定义**：如果城市 `A` 和城市 `B` 直接或间接通过道路相连，那么它们属于同一个连通分量。初始时，每个城市都是一个独立的连通分量。
- **合并连通分量**：通过并查集（Disjoint Set Union, DSU）算法，代码将直接或间接相连的城市合并到同一个连通分量中。
- **最终连通分量数**：`count` 是最终的连通分量个数。如果所有城市已经连通，那么 `count = 1`；如果有多个连通分量，说明城市被分成了多个不连通的部分。
- **最少需要修建的道路**：要将所有城市连通，需要的最少道路数就是 `连通分量数 - 1`。这是因为每次修建一条道路可以连接两个连通分量，从而将总连通分量数减少 1。例如：
  - 如果有 3 个连通分量（A、B、C），只需要修建 2 条道路（A-B 和 B-C）即可全部连通。
  - 如果有 1 个连通分量（已经全部连通），则不需要修建道路，结果为 `1 - 1 = 0`。
### 代码逻辑总结：
1. 初始化并查集，每个城市是自己的父节点。
2. 处理所有道路信息，合并相连的城市。
3. 统计最终的连通分量数 `count`。
4. 输出 `count - 1`，即需要修建的最少道路数。

如果没有 `-1`，结果会是连通分量的数量，而题目要求的是“需要修建的道路数”，所以必须减 1。
